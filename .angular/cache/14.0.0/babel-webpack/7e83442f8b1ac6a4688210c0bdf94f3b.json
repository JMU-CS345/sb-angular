{"ast":null,"code":"import { Subject, ReplaySubject } from 'rxjs';\nimport { CableService } from './cable.service';\nimport { filter, mapTo, map, startWith, first } from 'rxjs/operators';\nimport { merge, interval, timer } from 'rxjs';\nimport { distinctUntilChanged } from 'rxjs/operators';\nimport { Api } from './api';\nimport { AuthService } from '@auth0/auth0-angular';\nimport { UserInfoService } from './user-info.service';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"./cable.service\";\nimport * as i2 from \"./api\";\nimport * as i3 from \"@auth0/auth0-angular\";\nimport * as i4 from \"./user-info.service\";\nexport let DataService = /*#__PURE__*/(() => {\n  class DataService {\n    constructor(cableService, api, auth, userInfo) {\n      this.cableService = cableService;\n      this.api = api;\n      this.auth = auth;\n      this.userInfo = userInfo;\n      this.resetting = false;\n      this.pulse = new Subject();\n      this.users_by_team = {};\n      this.received = new Subject();\n      this.holds = {};\n      this.values = {};\n      this.unloaders = new Set();\n    }\n\n    init() {\n      this.channel = this.cableService.channel('SyncChannel');\n      this.channel.received().subscribe(msg => this.received.next(msg));\n      this.received.pipe(filter(msg => {\n        return msg.hasOwnProperty('selector');\n      })).subscribe(msg => this.processMessage(msg)); //this.channel.perform(\"cancelsync\", { selector: \"all\" });\n\n      this.syncers = new SyncerRegistry(this.channel, this.received);\n      this.channel.connected().subscribe();\n      this.channel.disconnected().subscribe();\n      this.status = merge(this.channel.connected().pipe(mapTo(\"connected\")), this.channel.disconnected().pipe(mapTo(\"disconnected\")), this.channel.rejected().pipe(mapTo(\"rejected\"))).pipe(startWith('uninitialized'), distinctUntilChanged());\n      this.status.subscribe(x => console.log(`status: ${x}`));\n      this.status.subscribe(s => {\n        if (s == 'disconnected') {\n          this.resetting = true; // give the UI a second to reset\n\n          timer(100).pipe(first()).subscribe(x => {\n            this.reset();\n            this.resetting = false;\n          });\n        }\n      });\n      this.api.get(\"api/me\").subscribe();\n      this.status.subscribe(x => {\n        if (x == 'connected') {\n          this.auth.getAccessTokenSilently().subscribe(t => {\n            this.channel.perform(\"auth\", {\n              token: t\n            });\n            this.channel.received().subscribe(msg => {\n              if (msg.action == 'sync' && msg.selector == 'users') {\n                this.users = msg.data;\n              }\n\n              if (msg.selector.startsWith('users_')) {\n                this.users_by_team[msg.selector] = msg.data;\n                this.users = [];\n                let ids = [];\n\n                for (const key in this.users_by_team) {\n                  for (const user of this.users_by_team[key]) {\n                    if (!ids.includes(user.id)) {\n                      this.users.push(user);\n                      ids.push(user.id);\n                    }\n                  }\n                }\n              }\n\n              if (msg.selector == 'user_pulse') {\n                this.pulse.next(msg.data.id);\n                timer(100).pipe(first()).subscribe(x => {\n                  this.pulse.next(-1);\n                });\n              }\n            });\n          });\n        }\n      });\n      this.syncLoop = interval(1000).subscribe(val => this.doSync());\n      this.isConnected = this.status.pipe(map(val => val == 'connected'));\n      this.isDisconnected = this.status.pipe(map(val => val == 'disconnected'));\n    }\n\n    stop() {}\n\n    reset() {\n      for (let key in this.holds) {\n        let hold = this.holds[key];\n        hold.fastUnload();\n        delete this.holds[hold.address];\n        delete this.values[hold.address];\n      }\n\n      for (let sub of this.unloaders) {\n        sub.unsubscribe();\n      }\n    }\n\n    doSync() {\n      for (let key in this.holds) {\n        let hold = this.holds[key];\n\n        if (hold.needsUpdate) {\n          hold.refresh();\n        }\n      }\n    }\n\n    processMessage(msg) {}\n\n    load(address, selectors) {\n      let hold = this.holds[address];\n\n      if (!hold) {\n        this.holds[address] = new Hold(address, this.channel, this.api, this.syncers);\n        hold = this.holds[address];\n        hold.refresh();\n      }\n\n      hold.count++;\n      hold.syncOn(selectors);\n      this.values[address] = hold.value;\n    }\n\n    unload(address, selectors) {\n      let sub = interval(5000).pipe(first()).subscribe(() => {\n        let hold = this.holds[address];\n\n        if (hold) {\n          hold.count--;\n          hold.release(selectors);\n\n          if (hold.count == 0) {\n            delete this.holds[address];\n            delete this.values[address];\n          }\n        }\n\n        this.unloaders.delete(sub);\n      });\n      this.unloaders.add(sub);\n    }\n\n    fastUnload(address) {\n      let hold = this.holds[address];\n      hold.fastUnload();\n      delete this.holds[address];\n      delete this.values[address];\n    }\n    /*\n    core.js:6157 ERROR TypeError: Cannot read property 'next' of undefined\n      at DataService.update (data.service.ts:159)\n      at ProjectIssueListComponent.onReorder (project-issue-list.component.ts:101)\n      at ProjectIssueListComponent_sb_issue_list_3_Template_sb_issue_list_reorder_0_listener (project-issue-list.component.html:11)\n      at executeListenerWithErrorHandling (core.js:15220)\n      at wrapListenerIn_markDirtyAndPreventDefault (core.js:15255)\n      at SafeSubscriber.schedulerFn [as _next] (core.js:25910)\n      at SafeSubscriber.__tryOrUnsub (Subscriber.js:183)\n      at SafeSubscriber.next (Subscriber.js:122)\n      at Subscriber._next (Subscriber.js:72)\n      at Subscriber.next (Subscriber.js:49)\n    */\n\n\n    update(address, newValue) {\n      this.values[address].next(newValue);\n    }\n\n    forceRefresh(address) {\n      this.holds[address].forceRefresh();\n    }\n\n  }\n\n  DataService.ɵfac = function DataService_Factory(t) {\n    return new (t || DataService)(i0.ɵɵinject(i1.CableService), i0.ɵɵinject(i2.Api), i0.ɵɵinject(i3.AuthService), i0.ɵɵinject(i4.UserInfoService));\n  };\n\n  DataService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: DataService,\n    factory: DataService.ɵfac,\n    providedIn: 'root'\n  });\n  return DataService;\n})();\n\nclass Hold {\n  constructor(address, syncChannel, api, syncers) {\n    this.syncChannel = syncChannel;\n    this.api = api;\n    this.syncers = syncers;\n    this.count = 0;\n    this.selectorCounts = {};\n    this.selectorSubscriptions = {};\n    this.uniqueSelectors = [];\n    this.value = new ReplaySubject();\n    this._needsUpdate = false;\n    this.address = address;\n    this.value.next(null);\n  }\n\n  refresh() {\n    this.api.get('api/' + this.address).subscribe(success => {\n      this.value.next(success);\n    }, error => {\n      console.log(error);\n    });\n  }\n\n  forceRefresh() {\n    this._needsUpdate = true;\n  }\n\n  get needsUpdate() {\n    if (this._needsUpdate) {\n      this._needsUpdate = false;\n      return true;\n    }\n\n    return false;\n  }\n\n  syncOn(selectors) {\n    for (let selector of selectors) {\n      if (!this.selectorCounts.hasOwnProperty(selector)) {\n        this.selectorCounts[selector] = 0;\n      }\n\n      this.selectorCounts[selector]++;\n\n      if (this.selectorCounts[selector] == 1) {\n        this.selectorSubscriptions[selector] = this.syncers.get(selector).sync().subscribe(msg => this._needsUpdate = true);\n      }\n    }\n  }\n\n  release(selectors) {\n    for (let selector of selectors) {\n      this.selectorCounts[selector]--;\n\n      if (this.selectorCounts[selector] == 0) {\n        this.syncers.get(selector).unsync();\n        this.selectorSubscriptions[selector].unsubscribe();\n      }\n    }\n  }\n\n  fastUnload() {\n    for (let selector in this.selectorCounts) {\n      this.syncers.get(selector).unsync();\n      this.selectorSubscriptions[selector].unsubscribe();\n    }\n  }\n\n}\n\nclass CountingSyncer {\n  constructor(selector, syncChannel, received) {\n    this.syncChannel = syncChannel;\n    this.received = received;\n    this.counter = 0;\n    this.syncs = new Subject();\n    this.selector = selector;\n  }\n\n  sync() {\n    console.log(`sync ${this.selector}`);\n    this.counter++;\n\n    if (this.counter == 1) {\n      this.subscribe();\n    }\n\n    return this.syncs;\n  }\n\n  unsync() {\n    this.counter--;\n\n    if (this.counter == 0) {\n      this.unsubscribe();\n    }\n  }\n\n  subscribe() {\n    this.subscription = this.received.subscribe(msg => {\n      if (msg.hasOwnProperty('selector') && msg.selector === this.selector) {\n        this.syncs.next(msg);\n      }\n    });\n    this.syncChannel.perform(\"sync\", {\n      selector: this.selector\n    });\n  }\n\n  unsubscribe() {\n    this.syncChannel.perform(\"cancelsync\", {\n      selector: this.selector\n    });\n    this.subscription.unsubscribe();\n  }\n\n}\n\nclass SyncerRegistry {\n  constructor(syncChannel, received) {\n    this.syncChannel = syncChannel;\n    this.received = received;\n    this.syncers = {};\n  }\n\n  get(selector) {\n    if (!this.syncers[selector]) {\n      this.syncers[selector] = new CountingSyncer(selector, this.syncChannel, this.received);\n    }\n\n    return this.syncers[selector];\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}