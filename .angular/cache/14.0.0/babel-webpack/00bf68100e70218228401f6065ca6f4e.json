{"ast":null,"code":"import { __awaiter, __decorate, __param } from 'tslib';\nimport { InjectionToken, EventEmitter, Inject, ElementRef, NgZone, Input, Output, Directive, NgModule } from '@angular/core';\nimport { of, EMPTY, fromEvent, Observable } from 'rxjs';\nimport { debounceTime, switchMap } from 'rxjs/operators';\nimport * as ɵngcc0 from '@angular/core';\n\nclass ChangeFilter {\n  constructor(changes) {\n    this.changes = changes;\n  }\n\n  static of(changes) {\n    return new ChangeFilter(changes);\n  }\n\n  notEmpty(key) {\n    if (this.changes[key]) {\n      const value = this.changes[key].currentValue;\n\n      if (value !== undefined && value !== null) {\n        return of(value);\n      }\n    }\n\n    return EMPTY;\n  }\n\n  has(key) {\n    if (this.changes[key]) {\n      const value = this.changes[key].currentValue;\n      return of(value);\n    }\n\n    return EMPTY;\n  }\n\n  notFirst(key) {\n    if (this.changes[key] && !this.changes[key].isFirstChange()) {\n      const value = this.changes[key].currentValue;\n      return of(value);\n    }\n\n    return EMPTY;\n  }\n\n  notFirstAndEmpty(key) {\n    if (this.changes[key] && !this.changes[key].isFirstChange()) {\n      const value = this.changes[key].currentValue;\n\n      if (value !== undefined && value !== null) {\n        return of(value);\n      }\n    }\n\n    return EMPTY;\n  }\n\n}\n\nconst NGX_ECHARTS_CONFIG = new InjectionToken('NGX_ECHARTS_CONFIG');\nlet NgxEchartsDirective = /*#__PURE__*/(() => {\n  let NgxEchartsDirective = class NgxEchartsDirective {\n    constructor(config, el, ngZone) {\n      this.el = el;\n      this.ngZone = ngZone;\n      this.autoResize = true;\n      this.loadingType = 'default'; // ngx-echarts events\n\n      this.chartInit = new EventEmitter();\n      this.optionsError = new EventEmitter(); // echarts mouse events\n\n      this.chartClick = this.createLazyEvent('click');\n      this.chartDblClick = this.createLazyEvent('dblclick');\n      this.chartMouseDown = this.createLazyEvent('mousedown');\n      this.chartMouseMove = this.createLazyEvent('mousemove');\n      this.chartMouseUp = this.createLazyEvent('mouseup');\n      this.chartMouseOver = this.createLazyEvent('mouseover');\n      this.chartMouseOut = this.createLazyEvent('mouseout');\n      this.chartGlobalOut = this.createLazyEvent('globalout');\n      this.chartContextMenu = this.createLazyEvent('contextmenu'); // echarts mouse events\n\n      this.chartLegendSelectChanged = this.createLazyEvent('legendselectchanged');\n      this.chartLegendSelected = this.createLazyEvent('legendselected');\n      this.chartLegendUnselected = this.createLazyEvent('legendunselected');\n      this.chartLegendScroll = this.createLazyEvent('legendscroll');\n      this.chartDataZoom = this.createLazyEvent('datazoom');\n      this.chartDataRangeSelected = this.createLazyEvent('datarangeselected');\n      this.chartTimelineChanged = this.createLazyEvent('timelinechanged');\n      this.chartTimelinePlayChanged = this.createLazyEvent('timelineplaychanged');\n      this.chartRestore = this.createLazyEvent('restore');\n      this.chartDataViewChanged = this.createLazyEvent('dataviewchanged');\n      this.chartMagicTypeChanged = this.createLazyEvent('magictypechanged');\n      this.chartPieSelectChanged = this.createLazyEvent('pieselectchanged');\n      this.chartPieSelected = this.createLazyEvent('pieselected');\n      this.chartPieUnselected = this.createLazyEvent('pieunselected');\n      this.chartMapSelectChanged = this.createLazyEvent('mapselectchanged');\n      this.chartMapSelected = this.createLazyEvent('mapselected');\n      this.chartMapUnselected = this.createLazyEvent('mapunselected');\n      this.chartAxisAreaSelected = this.createLazyEvent('axisareaselected');\n      this.chartFocusNodeAdjacency = this.createLazyEvent('focusnodeadjacency');\n      this.chartUnfocusNodeAdjacency = this.createLazyEvent('unfocusnodeadjacency');\n      this.chartBrush = this.createLazyEvent('brush');\n      this.chartBrushEnd = this.createLazyEvent('brushend');\n      this.chartBrushSelected = this.createLazyEvent('brushselected');\n      this.chartRendered = this.createLazyEvent('rendered');\n      this.chartFinished = this.createLazyEvent('finished');\n      this.currentOffsetWidth = 0;\n      this.currentOffsetHeight = 0;\n      this.echarts = config.echarts;\n    }\n\n    ngOnChanges(changes) {\n      const filter = ChangeFilter.of(changes);\n      filter.notFirstAndEmpty('options').subscribe(opt => this.onOptionsChange(opt));\n      filter.notFirstAndEmpty('merge').subscribe(opt => this.setOption(opt));\n      filter.has('loading').subscribe(v => this.toggleLoading(!!v));\n      filter.notFirst('theme').subscribe(() => this.refreshChart());\n    }\n\n    ngOnInit() {\n      this.resizeSub = fromEvent(window, 'resize').pipe(debounceTime(50)).subscribe(() => {\n        if (this.autoResize && window.innerWidth !== this.currentWindowWidth) {\n          this.currentWindowWidth = window.innerWidth;\n          this.currentOffsetWidth = this.el.nativeElement.offsetWidth;\n          this.currentOffsetHeight = this.el.nativeElement.offsetHeight;\n          this.resize();\n        }\n      });\n    }\n\n    ngOnDestroy() {\n      if (this.resizeSub) {\n        this.resizeSub.unsubscribe();\n      }\n\n      this.dispose();\n    }\n\n    ngDoCheck() {\n      // No heavy work in DoCheck!\n      if (this.chart && this.autoResize) {\n        const offsetWidth = this.el.nativeElement.offsetWidth;\n        const offsetHeight = this.el.nativeElement.offsetHeight;\n\n        if (this.currentOffsetWidth !== offsetWidth || this.currentOffsetHeight !== offsetHeight) {\n          this.currentOffsetWidth = offsetWidth;\n          this.currentOffsetHeight = offsetHeight;\n          this.resize();\n        }\n      }\n    }\n\n    ngAfterViewInit() {\n      setTimeout(() => this.initChart());\n    }\n\n    dispose() {\n      if (this.chart) {\n        this.chart.dispose();\n        this.chart = null;\n      }\n    }\n\n    resize() {\n      if (this.chart) {\n        this.chart.resize();\n      }\n    }\n\n    toggleLoading(loading) {\n      if (this.chart) {\n        loading ? this.chart.showLoading(this.loadingType, this.loadingOpts) : this.chart.hideLoading();\n      }\n    }\n\n    setOption(option, opts) {\n      if (this.chart) {\n        try {\n          this.chart.setOption(option, opts);\n        } catch (e) {\n          console.error(e);\n          this.optionsError.emit(e);\n        }\n      }\n    }\n\n    refreshChart() {\n      return __awaiter(this, void 0, void 0, function* () {\n        this.dispose();\n        yield this.initChart();\n      });\n    }\n\n    createChart() {\n      this.currentWindowWidth = window.innerWidth;\n      this.currentOffsetWidth = this.el.nativeElement.offsetWidth;\n      this.currentOffsetHeight = this.el.nativeElement.offsetHeight;\n      const dom = this.el.nativeElement;\n\n      if (window && window.getComputedStyle) {\n        const prop = window.getComputedStyle(dom, null).getPropertyValue('height');\n\n        if ((!prop || prop === '0px') && (!dom.style.height || dom.style.height === '0px')) {\n          dom.style.height = '400px';\n        }\n      } // here a bit tricky: we check if the echarts module is provided as function returning native import('...') then use the promise\n      // otherwise create the function that imitates behaviour above with a provided as is module\n\n\n      return this.ngZone.runOutsideAngular(() => {\n        const load = typeof this.echarts === 'function' ? this.echarts : () => Promise.resolve(this.echarts);\n        return load().then(({\n          init\n        }) => init(dom, this.theme, this.initOpts));\n      });\n    }\n\n    initChart() {\n      return __awaiter(this, void 0, void 0, function* () {\n        yield this.onOptionsChange(this.options);\n\n        if (this.merge && this.chart) {\n          this.setOption(this.merge);\n        }\n      });\n    }\n\n    onOptionsChange(opt) {\n      return __awaiter(this, void 0, void 0, function* () {\n        if (!opt) {\n          return;\n        }\n\n        if (this.chart) {\n          this.setOption(this.options, true);\n        } else {\n          this.chart = yield this.createChart();\n          this.chartInit.emit(this.chart);\n          this.setOption(this.options, true);\n        }\n      });\n    } // allows to lazily bind to only those events that are requested through the `@Output` by parent components\n    // see https://stackoverflow.com/questions/51787972/optimal-reentering-the-ngzone-from-eventemitter-event for more info\n\n\n    createLazyEvent(eventName) {\n      return this.chartInit.pipe(switchMap(chart => new Observable(observer => {\n        chart.on(eventName, data => this.ngZone.run(() => observer.next(data)));\n        return () => chart.off(eventName);\n      })));\n    }\n\n  };\n\n  NgxEchartsDirective.ɵfac = function NgxEchartsDirective_Factory(t) {\n    return new (t || NgxEchartsDirective)(ɵngcc0.ɵɵdirectiveInject(NGX_ECHARTS_CONFIG), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n  };\n\n  NgxEchartsDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: NgxEchartsDirective,\n    selectors: [[\"echarts\"], [\"\", \"echarts\", \"\"]],\n    inputs: {\n      autoResize: \"autoResize\",\n      loadingType: \"loadingType\",\n      options: \"options\",\n      theme: \"theme\",\n      loading: \"loading\",\n      initOpts: \"initOpts\",\n      merge: \"merge\",\n      loadingOpts: \"loadingOpts\"\n    },\n    outputs: {\n      chartInit: \"chartInit\",\n      optionsError: \"optionsError\",\n      chartClick: \"chartClick\",\n      chartDblClick: \"chartDblClick\",\n      chartMouseDown: \"chartMouseDown\",\n      chartMouseMove: \"chartMouseMove\",\n      chartMouseUp: \"chartMouseUp\",\n      chartMouseOver: \"chartMouseOver\",\n      chartMouseOut: \"chartMouseOut\",\n      chartGlobalOut: \"chartGlobalOut\",\n      chartContextMenu: \"chartContextMenu\",\n      chartLegendSelectChanged: \"chartLegendSelectChanged\",\n      chartLegendSelected: \"chartLegendSelected\",\n      chartLegendUnselected: \"chartLegendUnselected\",\n      chartLegendScroll: \"chartLegendScroll\",\n      chartDataZoom: \"chartDataZoom\",\n      chartDataRangeSelected: \"chartDataRangeSelected\",\n      chartTimelineChanged: \"chartTimelineChanged\",\n      chartTimelinePlayChanged: \"chartTimelinePlayChanged\",\n      chartRestore: \"chartRestore\",\n      chartDataViewChanged: \"chartDataViewChanged\",\n      chartMagicTypeChanged: \"chartMagicTypeChanged\",\n      chartPieSelectChanged: \"chartPieSelectChanged\",\n      chartPieSelected: \"chartPieSelected\",\n      chartPieUnselected: \"chartPieUnselected\",\n      chartMapSelectChanged: \"chartMapSelectChanged\",\n      chartMapSelected: \"chartMapSelected\",\n      chartMapUnselected: \"chartMapUnselected\",\n      chartAxisAreaSelected: \"chartAxisAreaSelected\",\n      chartFocusNodeAdjacency: \"chartFocusNodeAdjacency\",\n      chartUnfocusNodeAdjacency: \"chartUnfocusNodeAdjacency\",\n      chartBrush: \"chartBrush\",\n      chartBrushEnd: \"chartBrushEnd\",\n      chartBrushSelected: \"chartBrushSelected\",\n      chartRendered: \"chartRendered\",\n      chartFinished: \"chartFinished\"\n    },\n    exportAs: [\"echarts\"],\n    features: [ɵngcc0.ɵɵNgOnChangesFeature]\n  });\n\n  __decorate([Input()], NgxEchartsDirective.prototype, \"options\", void 0);\n\n  __decorate([Input()], NgxEchartsDirective.prototype, \"theme\", void 0);\n\n  __decorate([Input()], NgxEchartsDirective.prototype, \"loading\", void 0);\n\n  __decorate([Input()], NgxEchartsDirective.prototype, \"initOpts\", void 0);\n\n  __decorate([Input()], NgxEchartsDirective.prototype, \"merge\", void 0);\n\n  __decorate([Input()], NgxEchartsDirective.prototype, \"autoResize\", void 0);\n\n  __decorate([Input()], NgxEchartsDirective.prototype, \"loadingType\", void 0);\n\n  __decorate([Input()], NgxEchartsDirective.prototype, \"loadingOpts\", void 0);\n\n  __decorate([Output()], NgxEchartsDirective.prototype, \"chartInit\", void 0);\n\n  __decorate([Output()], NgxEchartsDirective.prototype, \"optionsError\", void 0);\n\n  __decorate([Output()], NgxEchartsDirective.prototype, \"chartClick\", void 0);\n\n  __decorate([Output()], NgxEchartsDirective.prototype, \"chartDblClick\", void 0);\n\n  __decorate([Output()], NgxEchartsDirective.prototype, \"chartMouseDown\", void 0);\n\n  __decorate([Output()], NgxEchartsDirective.prototype, \"chartMouseMove\", void 0);\n\n  __decorate([Output()], NgxEchartsDirective.prototype, \"chartMouseUp\", void 0);\n\n  __decorate([Output()], NgxEchartsDirective.prototype, \"chartMouseOver\", void 0);\n\n  __decorate([Output()], NgxEchartsDirective.prototype, \"chartMouseOut\", void 0);\n\n  __decorate([Output()], NgxEchartsDirective.prototype, \"chartGlobalOut\", void 0);\n\n  __decorate([Output()], NgxEchartsDirective.prototype, \"chartContextMenu\", void 0);\n\n  __decorate([Output()], NgxEchartsDirective.prototype, \"chartLegendSelectChanged\", void 0);\n\n  __decorate([Output()], NgxEchartsDirective.prototype, \"chartLegendSelected\", void 0);\n\n  __decorate([Output()], NgxEchartsDirective.prototype, \"chartLegendUnselected\", void 0);\n\n  __decorate([Output()], NgxEchartsDirective.prototype, \"chartLegendScroll\", void 0);\n\n  __decorate([Output()], NgxEchartsDirective.prototype, \"chartDataZoom\", void 0);\n\n  __decorate([Output()], NgxEchartsDirective.prototype, \"chartDataRangeSelected\", void 0);\n\n  __decorate([Output()], NgxEchartsDirective.prototype, \"chartTimelineChanged\", void 0);\n\n  __decorate([Output()], NgxEchartsDirective.prototype, \"chartTimelinePlayChanged\", void 0);\n\n  __decorate([Output()], NgxEchartsDirective.prototype, \"chartRestore\", void 0);\n\n  __decorate([Output()], NgxEchartsDirective.prototype, \"chartDataViewChanged\", void 0);\n\n  __decorate([Output()], NgxEchartsDirective.prototype, \"chartMagicTypeChanged\", void 0);\n\n  __decorate([Output()], NgxEchartsDirective.prototype, \"chartPieSelectChanged\", void 0);\n\n  __decorate([Output()], NgxEchartsDirective.prototype, \"chartPieSelected\", void 0);\n\n  __decorate([Output()], NgxEchartsDirective.prototype, \"chartPieUnselected\", void 0);\n\n  __decorate([Output()], NgxEchartsDirective.prototype, \"chartMapSelectChanged\", void 0);\n\n  __decorate([Output()], NgxEchartsDirective.prototype, \"chartMapSelected\", void 0);\n\n  __decorate([Output()], NgxEchartsDirective.prototype, \"chartMapUnselected\", void 0);\n\n  __decorate([Output()], NgxEchartsDirective.prototype, \"chartAxisAreaSelected\", void 0);\n\n  __decorate([Output()], NgxEchartsDirective.prototype, \"chartFocusNodeAdjacency\", void 0);\n\n  __decorate([Output()], NgxEchartsDirective.prototype, \"chartUnfocusNodeAdjacency\", void 0);\n\n  __decorate([Output()], NgxEchartsDirective.prototype, \"chartBrush\", void 0);\n\n  __decorate([Output()], NgxEchartsDirective.prototype, \"chartBrushEnd\", void 0);\n\n  __decorate([Output()], NgxEchartsDirective.prototype, \"chartBrushSelected\", void 0);\n\n  __decorate([Output()], NgxEchartsDirective.prototype, \"chartRendered\", void 0);\n\n  __decorate([Output()], NgxEchartsDirective.prototype, \"chartFinished\", void 0);\n\n  NgxEchartsDirective = __decorate([__param(0, Inject(NGX_ECHARTS_CONFIG))], NgxEchartsDirective);\n  return NgxEchartsDirective;\n})();\nvar NgxEchartsModule_1;\nlet NgxEchartsModule = NgxEchartsModule_1 = class NgxEchartsModule {\n  static forRoot(config) {\n    return {\n      ngModule: NgxEchartsModule_1,\n      providers: [{\n        provide: NGX_ECHARTS_CONFIG,\n        useValue: config\n      }]\n    };\n  }\n\n  static forChild() {\n    return {\n      ngModule: NgxEchartsModule_1\n    };\n  }\n\n};\n\nNgxEchartsModule.ɵfac = function NgxEchartsModule_Factory(t) {\n  return new (t || NgxEchartsModule)();\n};\n\nNgxEchartsModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n  type: NgxEchartsModule\n});\nNgxEchartsModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NgxEchartsModule, {\n    declarations: [NgxEchartsDirective],\n    exports: [NgxEchartsDirective]\n  });\n})();\n/*\n * Public API Surface of ngx-echarts\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { NGX_ECHARTS_CONFIG, NgxEchartsDirective, NgxEchartsModule }; //# sourceMappingURL=ngx-echarts.js.map","map":null,"metadata":{},"sourceType":"module"}